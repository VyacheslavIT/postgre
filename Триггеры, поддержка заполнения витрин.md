
Скрипт и развернутое описание задачи – в ЛК (файл hw_triggers.sql) или по ссылке: https://disk.yandex.ru/d/l70AvknAepIJXQ

В БД создана структура, описывающая товары (таблица goods) и продажи (таблица sales).

Есть запрос для генерации отчета – сумма продаж по каждому товару.

БД была денормализована, создана таблица (витрина), структура которой повторяет структуру отчета.

Создать триггер на таблице продаж, для поддержки данных в витрине в актуальном состоянии (вычисляющий при каждой продаже сумму и записывающий её в витрину)

Подсказка: не забыть, что кроме INSERT есть еще UPDATE и DELETE

Задание со звездочкой*
Чем такая схема (витрина+триггер) предпочтительнее отчета, создаваемого "по требованию" (кроме производительности)?
Подсказка: В реальной жизни возможны изменения цен.

```sql
первый триггер для добавления записи

CREATE OR REPLACE FUNCTION insert_good_sum_mart()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, существует ли запись для данного товара
    IF EXISTS (SELECT * FROM pract_functions.good_sum_mart WHERE good_name = (SELECT good_name FROM pract_functions.goods WHERE goods_id = NEW.good_id)) THEN
        -- Увеличиваем сумму продажи
        UPDATE pract_functions.good_sum_mart 
        SET sum_sale = sum_sale + (NEW.sales_qty * (SELECT good_price FROM pract_functions.goods WHERE goods_id = NEW.good_id))
        WHERE good_name = (SELECT good_name FROM pract_functions.goods WHERE goods_id = NEW.good_id);
    ELSE
        -- Если записи нет, создаем новую
        INSERT INTO pract_functions.good_sum_mart (good_name, sum_sale)
        SELECT G.good_name, SUM(G.good_price * NEW.sales_qty)
        FROM pract_functions.goods G
        WHERE G.goods_id = NEW.good_id
        GROUP BY G.good_name;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер
CREATE TRIGGER insert_good_sum_mart_trigger
AFTER INSERT ON pract_functions.sales
FOR EACH ROW
EXECUTE FUNCTION insert_good_sum_mart();
```

Проверяем что таблица пуста


![image](https://github.com/VyacheslavIT/postgre/assets/136000255/c317dec6-6fa6-4ca2-93fb-8aa63f698173)


Добавляем продажу

```sql
INSERT INTO pract_functions.sales (good_id, sales_qty) VALUES (1, 10)
```

Данные появились

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/89b7b145-d2c3-4e05-a4b3-d18145d39490)

Еще раз добавляем продажу


```sql
INSERT INTO pract_functions.sales (good_id, sales_qty) VALUES (1, 10)

```

Запись обновилась

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/6e0e990d-9dac-457f-825a-0d6bddd005f6)



```sql

Данный триггер обновляет сумму в таблице good_sum_mart если мы удаляем запись в таблице sales

CREATE OR REPLACE FUNCTION update_good_sum_mart_on_delete()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем сумму продажи после удаления записи из таблицы sales
    UPDATE pract_functions.good_sum_mart 
    SET sum_sale = sum_sale - (OLD.sales_qty * (SELECT good_price FROM pract_functions.goods WHERE goods_id = OLD.good_id))
    WHERE good_name = (SELECT good_name FROM pract_functions.goods WHERE goods_id = OLD.good_id);

    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер
CREATE TRIGGER update_good_sum_mart_on_delete_trigger
AFTER DELETE ON pract_functions.sales
FOR EACH ROW
EXECUTE FUNCTION update_good_sum_mart_on_delete();

```

Удаляем запись

```sql
delete from pract_functions.sales where sales_id = '21'
```

Проверяем

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/d82029ec-aec9-4901-b3b7-22d8003cdc39)


```sql
CREATE OR REPLACE FUNCTION update_good_sum_mart_on_update()
RETURNS TRIGGER AS $$
BEGIN
    
	 IF EXISTS (SELECT * FROM pract_functions.good_sum_mart WHERE good_name = (SELECT good_name FROM pract_functions.goods WHERE goods_id = NEW.good_id)) THEN
        --если только одна запись в таблице
        UPDATE pract_functions.good_sum_mart 
        SET sum_sale = sum_sale+(NEW.sales_qty * (SELECT good_price FROM pract_functions.goods WHERE goods_id = NEW.good_id))
        WHERE good_name = (SELECT good_name FROM pract_functions.goods WHERE goods_id = NEW.good_id);
    ELSE
   
    -- Обновляем сумму продажи после удаления записи из таблицы sales
    UPDATE pract_functions.good_sum_mart 
    SET sum_sale = sum_sale+(OLD.sales_qty * (SELECT good_price FROM pract_functions.goods WHERE goods_id = OLD.good_id))
    WHERE good_name = (SELECT good_name FROM pract_functions.goods WHERE goods_id = OLD.good_id);

    
END IF;

RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер
CREATE TRIGGER update_good_sum_mart_on_update_trigger
AFTER UPDATE ON pract_functions.sales
FOR EACH ROW
EXECUTE FUNCTION update_good_sum_mart_on_update();

```

Проверяем 

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/524fc0ed-e2d7-4f1a-952a-12fabd263514)


Добави несколько записей в продажи 

```sql
INSERT INTO pract_functions.sales (good_id, sales_qty) VALUES (1, 10)
```

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/3d8837ea-2906-4658-a2f5-96a45e97049c)

Обновим запись в продажах

```sql
update pract_functions.sales set  sales_qty = '100' where sales_id = '43'
```


