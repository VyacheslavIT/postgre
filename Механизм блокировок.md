
* Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

```sql

postgres=# alter system set log_lock_waits = on;
ALTER SYSTEM


SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

postgres=# show log_lock_waits;
 log_lock_waits
----------------
 on
(1 row)

```

```sql
postgres=# alter system set log_min_duration_statement = "200ms";
ALTER SYSTEM
postgres=#

postgres=# SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

postgres=# show log_min_duration_statement;
 log_min_duration_statement
----------------------------
 200ms
(1 row)

```

Теперь транзакции, у которых длительность превышает 200ms будут заноситься в лог

* Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/dfc05f6a-cc08-4635-94ea-e7e646d4d57a)


--------------------


* Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.

```sql

postgres=# begin;SELECT pg_backend_pid(); update products set product_id=2 where product_id=1;
BEGIN
 pg_backend_pid
----------------
           2313
(1 row)

UPDATE 1
postgres=*#

```

```sql

postgres=# begin;SELECT pg_backend_pid(); update products set product_id=3 where product_id=1;
BEGIN
 pg_backend_pid
----------------
           2370
(1 row)


```

```sql
postgres=# begin;SELECT pg_backend_pid(); update products set product_id=4 where product_id=1;
BEGIN
 pg_backend_pid
----------------
           2414
(1 row)

```

```sql

begin;SELECT pg_backend_pid(); update products set product_id=2 where product_id=1; 
begin;SELECT pg_backend_pid(); update products set product_id=3 where product_id=1; 
begin;SELECT pg_backend_pid(); update products set product_id=4 where product_id=1; 

```


```sql

postgres=# SELECT locktype, mode, granted, pid, pg_blocking_pids(pid) AS wait_for FROM pg_locks WHERE relation = 'products'::regclass;
 locktype |       mode       | granted | pid  | wait_for
----------+------------------+---------+------+----------
 relation | RowExclusiveLock | t       | 2414 | {2370}
 relation | RowExclusiveLock | t       | 2370 | {2313}
 relation | RowExclusiveLock | t       | 2313 | {}
 tuple    | ExclusiveLock    | t       | 2370 | {2313}
 tuple    | ExclusiveLock    | f       | 2414 | {2370}
(5 rows)

postgres=#

```


![image](https://github.com/VyacheslavIT/postgre/assets/136000255/3944dd62-c6a9-4e9e-9362-fc791171d014)




---------------------


* Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
```sql
первая сессия
begin;
UPDATE accounts SET amount = amount - 10 WHERE acc_no = 1;


UPDATE accounts SET amount = amount + 10 WHERE acc_no = 2;

вторая сессия
begin;
UPDATE accounts SET amount = amount - 20 WHERE acc_no = 2;

UPDATE accounts SET amount = amount + 20 WHERE acc_no = 3;


третия сессия
begin;
UPDATE accounts SET amount = amount - 30 WHERE acc_no = 3;

UPDATE accounts SET amount = amount + 30 WHERE acc_no = 1;
```

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/3478d6df-e55b-4875-bc31-c5d65b4b43d3)

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/717d9e07-be2f-4e70-b32a-8577d42fd6ab)

* Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

Разобраться в ситуации можно, в журнале видно кто кого заблокировал и какие запросы выполнялись.


---------------------


* Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
  
Задание со звездочкой*

Попробуйте воспроизвести такую ситуацию.

Думаю могут.

```sql

create table test (id serial primary key, field1 text,field2 text);
CREATE TABLE
postgres=# select * from test
postgres-# ;
 id | field1 | field2
----+--------+--------
(0 rows)

```

```sql
 insert into test (field1,field2)select md5(random()::text),md5(random()::text)from generate_series(1,10000);
INSERT 0 10000
postgres=# select * from test;
postgres=# postgres=#
```
---------------------
