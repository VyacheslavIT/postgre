
* Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

```sql

postgres=# alter system set log_lock_waits = on;
ALTER SYSTEM


SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

postgres=# show log_lock_waits;
 log_lock_waits
----------------
 on
(1 row)

```

```sql
postgres=# alter system set log_min_duration_statement = "200ms";
ALTER SYSTEM
postgres=#

postgres=# SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

postgres=# show log_min_duration_statement;
 log_min_duration_statement
----------------------------
 200ms
(1 row)

```

Теперь транзакции, у которых длительность превышает 200ms будут заноситься в лог

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/dfc05f6a-cc08-4635-94ea-e7e646d4d57a)


--------------------


* Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.





---------------------


* Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?


---------------------


* Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
  
Задание со звездочкой*

Попробуйте воспроизвести такую ситуацию.


---------------------
