
* Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

```sql

postgres=# alter system set log_lock_waits = on;
ALTER SYSTEM


SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

postgres=# show log_lock_waits;
 log_lock_waits
----------------
 on
(1 row)

```

```sql
postgres=# alter system set log_min_duration_statement = "200ms";
ALTER SYSTEM
postgres=#

postgres=# SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

postgres=# show log_min_duration_statement;
 log_min_duration_statement
----------------------------
 200ms
(1 row)

```

Теперь транзакции, у которых длительность превышает 200ms будут заноситься в лог

* Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/dfc05f6a-cc08-4635-94ea-e7e646d4d57a)


--------------------


* Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.


![image](https://github.com/VyacheslavIT/postgre/assets/136000255/0fff99e2-6c73-40a0-8ff4-15b14089e585)

![image](https://github.com/VyacheslavIT/postgre/assets/136000255/b4c64982-964a-4810-b811-59b4af3f6942)


![image](https://github.com/VyacheslavIT/postgre/assets/136000255/e51cb5a9-7e89-4b12-8b9d-e047b37a0fa0)

```sql

tuple         |        5 |    16398 |    0 |     1 |            |               |         |       |          | 7/8                | 1420 | ExclusiveLock    | f       | f        | 2024-01-26 08:32:19.156668+00
 tuple         |        5 |    16398 |    0 |     1 |            |               |         |       |          | 4/92               | 1361 | ExclusiveLock    | t       | f        |
 transactionid |          |          |      |       |            |           747 |         |       |          | 3/69               | 1291 | ExclusiveLock    | t       | f        |
 tuple         |        5 |    16398 |    0 |     1 |            |               |         |       |          | 6/6                | 1372 | ExclusiveLock    | f       | f        | 2024-01-26 08:30:47.768113+00
 transactionid |          |          |      |       |            |           747 |         |       |          | 4/92               | 1361 | ShareLock        | f       | f        | 2024-01-26 08:28:57.087487+00
 transactionid |          |          |      |       |            |           748 |         |       |          | 4/92               | 1361 | ExclusiveLock    | t       | f        |
 transactionid |          |          |      |       |            |           751 |         |       |          | 7/8                | 1420 | ExclusiveLock    | t       | f        |
 transactionid |          |          |      |       |            |           749 |         |       |          | 5/8                | 1366 | ExclusiveLock    | t       | f        |
 tuple         |        5 |    16398 |    0 |     1 |            |               |         |       |          | 5/8                | 1366 | ExclusiveLock    | f       | f        | 2024-01-26 08:30:17.168141+00
 transactionid |          |          |      |       |            |           750 |         |       |          | 6/6                | 1372 | ExclusiveLock    | t       | f        |
(22 rows)

```

---------------------


* Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?


---------------------


* Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
  
Задание со звездочкой*

Попробуйте воспроизвести такую ситуацию.


---------------------
